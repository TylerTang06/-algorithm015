# 学习笔记

## 数组、链表、跳表

### 数组

- 内存中一块连续的地址
- 同一种数据类型的固定长度的序列，golang中数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变
- 访问数组时间复杂度O(1)，插入删除操作时间复杂度为O(n)
- golang中slice底层是基于数组实现，len(),cap()时间复杂度均为O(1)
- 切片扩容规则：如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍；如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍

### 链表

- 链表的元素中包含指向临近元素的指针
- 查找操作时间复杂度O(n)
- 插入删除操作时间复杂度O(1)
- 链表的元素在内存中不是连续的，没有容量的概念
- golang标准库实现了container/list双向链表

### 跳表

- 跳表是链表的升维结构，在原始的链表上新增K个层级的索引，类似二分法
- 跳表存储数据必须有序
- 维护成本较高，每次修改元素都要修改每个层级的索引
- 插入、删除、搜索操作时间复杂度O(log n)
- 原理简单、容易实现、方便扩展、效率更高，Redis、LevelDB中均有使用
- 维护成本较高，每次修改元素都要修改每个层级的索引

## 栈、队列、优先队列、双端队列

### 栈、队列

- 栈先进后出LIFO(Last In First Out)
- 队列先进先出FIFO(First In Fist Out)
- 栈、队列查询复杂度均为O(n)

### 优先队列

- 插入操作时间复杂度O(1)
- 取值操作时间复杂度O(log n)
- goalng可以使用container/heap接口方便实现优先队列

### 双端队列

- 两端都可以提取、插入操作的队列
- golang可以使用container/list模拟栈、对列、双端队列

## 总结

本周队常用数据结构进行了复习，对跳表、优先队列等还需结合具体使用场景加强理解；本周仓促中能够完成基本任务，还需继续多投入时间。
学习中比较有疑问的地方，这些数据结构如何保证并发安全？